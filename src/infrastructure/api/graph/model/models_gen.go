// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type BooleanResultErrorResponse interface {
	IsBooleanResultErrorResponse()
}

type ChatErrorResponse interface {
	IsChatErrorResponse()
}

type MessageErrorResponse interface {
	IsMessageErrorResponse()
}

type MessagesArrayErrorResponse interface {
	IsMessagesArrayErrorResponse()
}

type PaginatedChatsErrorResponse interface {
	IsPaginatedChatsErrorResponse()
}

type PaginatedMessagesErrorResponse interface {
	IsPaginatedMessagesErrorResponse()
}

type BooleanResult struct {
	Result bool `json:"result"`
}

func (BooleanResult) IsBooleanResultErrorResponse() {}

type ChangeGroupChatData struct {
	Title *string `json:"title,omitempty"`
}

type ChangeMessageRequest struct {
	Content     *string          `json:"content,omitempty"`
	Attachments []*UploadingFile `json:"attachments,omitempty"`
	Mentioned   []*int           `json:"mentioned,omitempty"`
}

type Chat struct {
	ID         int           `json:"id"`
	Avatar     *SavedFile    `json:"avatar,omitempty"`
	Title      string        `json:"title"`
	Type       ChatType      `json:"type"`
	Members    []int         `json:"members"`
	IsArchived bool          `json:"isArchived"`
	OwnerID    int           `json:"ownerId"`
	Admins     []int         `json:"admins"`
	Actions    []*ChatAction `json:"actions"`
}

func (Chat) IsChatErrorResponse() {}

type ChatAction struct {
	Action      ActionTypes       `json:"action"`
	ActionUsers []*ChatActionUser `json:"actionUsers"`
}

type ChatActionUser struct {
	FullName string `json:"fullName"`
	ID       int    `json:"id"`
}

type CreateChatRequest struct {
	Avatar  *UploadingFile `json:"avatar,omitempty"`
	Title   *string        `json:"title,omitempty"`
	Members []int          `json:"members,omitempty"`
	User    *int           `json:"user,omitempty"`
}

type CreateMessageRequest struct {
	ChatID      int              `json:"chatId"`
	Type        MessageType      `json:"type"`
	Content     *string          `json:"content,omitempty"`
	Voice       *UploadingFile   `json:"voice,omitempty"`
	Attachments []*UploadingFile `json:"attachments,omitempty"`
	ReplyToID   *int             `json:"replyToId,omitempty"`
	Mentioned   []int            `json:"mentioned,omitempty"`
	Circle      *UploadingFile   `json:"circle,omitempty"`
}

type CreateReactionRequest struct {
	Content   string `json:"content"`
	MessageID int    `json:"messageId"`
}

type ErrorResponse struct {
	Message string `json:"message"`
}

func (ErrorResponse) IsPaginatedMessagesErrorResponse() {}

func (ErrorResponse) IsPaginatedChatsErrorResponse() {}

func (ErrorResponse) IsChatErrorResponse() {}

func (ErrorResponse) IsMessagesArrayErrorResponse() {}

func (ErrorResponse) IsMessageErrorResponse() {}

func (ErrorResponse) IsBooleanResultErrorResponse() {}

type Message struct {
	ID          int          `json:"id"`
	Type        MessageType  `json:"type"`
	SenderID    int          `json:"senderId"`
	ChatID      int          `json:"chatId"`
	Content     *string      `json:"content,omitempty"`
	Voice       *SavedFile   `json:"voice,omitempty"`
	Circle      *SavedFile   `json:"circle,omitempty"`
	ReplyToID   *int         `json:"replyToId,omitempty"`
	ReadedBy    []int        `json:"readedBy"`
	Reactions   []*Reaction  `json:"reactions"`
	Attachments []*SavedFile `json:"attachments"`
	Mentioned   []int        `json:"mentioned"`
	CreatedAt   string       `json:"createdAt"`
}

func (Message) IsMessageErrorResponse() {}

type MessagesArray struct {
	Messages []*Message `json:"messages"`
}

func (MessagesArray) IsMessagesArrayErrorResponse() {}

type PaginatedChats struct {
	Page     int     `json:"page"`
	NumPages int     `json:"numPages"`
	PerPage  int     `json:"perPage"`
	Total    int     `json:"total"`
	Data     []*Chat `json:"data"`
}

func (PaginatedChats) IsPaginatedChatsErrorResponse() {}

type PaginatedMessages struct {
	Offset int        `json:"offset"`
	Limit  int        `json:"limit"`
	Total  int        `json:"total"`
	ID     int        `json:"id"`
	Data   []*Message `json:"data,omitempty"`
}

func (PaginatedMessages) IsPaginatedMessagesErrorResponse() {}

type Reaction struct {
	Content string `json:"content"`
	UserID  int    `json:"userId"`
}

type SavedFile struct {
	OriginalURL       string  `json:"originalUrl"`
	OriginalFilename  string  `json:"originalFilename"`
	ConvertedURL      *string `json:"convertedUrl,omitempty"`
	ConvertedFilename *string `json:"convertedFilename,omitempty"`
}

type UploadingFile struct {
	Original  *UploadingFileMeta `json:"original"`
	Converted *UploadingFileMeta `json:"converted,omitempty"`
}

type UploadingFileMeta struct {
	URL            string              `json:"url"`
	Filename       string              `json:"filename"`
	Signature      string              `json:"signature"`
	SystemFiletype SystemFiletypesEnum `json:"systemFiletype"`
}

type ActionTypes string

const (
	ActionTypesWriting         ActionTypes = "writing"
	ActionTypesAudioRecording  ActionTypes = "audio_recording"
	ActionTypesAudioSending    ActionTypes = "audio_sending"
	ActionTypesCircleRecording ActionTypes = "circle_recording"
	ActionTypesCircleSending   ActionTypes = "circle_sending"
	ActionTypesFilesSending    ActionTypes = "files_sending"
)

var AllActionTypes = []ActionTypes{
	ActionTypesWriting,
	ActionTypesAudioRecording,
	ActionTypesAudioSending,
	ActionTypesCircleRecording,
	ActionTypesCircleSending,
	ActionTypesFilesSending,
}

func (e ActionTypes) IsValid() bool {
	switch e {
	case ActionTypesWriting, ActionTypesAudioRecording, ActionTypesAudioSending, ActionTypesCircleRecording, ActionTypesCircleSending, ActionTypesFilesSending:
		return true
	}
	return false
}

func (e ActionTypes) String() string {
	return string(e)
}

func (e *ActionTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionTypes", str)
	}
	return nil
}

func (e ActionTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChatType string

const (
	ChatTypeGroup         ChatType = "group"
	ChatTypeUser          ChatType = "user"
	ChatTypeSavedMessages ChatType = "saved_messages"
)

var AllChatType = []ChatType{
	ChatTypeGroup,
	ChatTypeUser,
	ChatTypeSavedMessages,
}

func (e ChatType) IsValid() bool {
	switch e {
	case ChatTypeGroup, ChatTypeUser, ChatTypeSavedMessages:
		return true
	}
	return false
}

func (e ChatType) String() string {
	return string(e)
}

func (e *ChatType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChatType", str)
	}
	return nil
}

func (e ChatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileType string

const (
	FileTypeImages    FileType = "images"
	FileTypeVideos    FileType = "videos"
	FileTypeDocuments FileType = "documents"
	FileTypeMusic     FileType = "music"
	FileTypeOther     FileType = "other"
	FileTypeAll       FileType = "all"
)

var AllFileType = []FileType{
	FileTypeImages,
	FileTypeVideos,
	FileTypeDocuments,
	FileTypeMusic,
	FileTypeOther,
	FileTypeAll,
}

func (e FileType) IsValid() bool {
	switch e {
	case FileTypeImages, FileTypeVideos, FileTypeDocuments, FileTypeMusic, FileTypeOther, FileTypeAll:
		return true
	}
	return false
}

func (e FileType) String() string {
	return string(e)
}

func (e *FileType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileType", str)
	}
	return nil
}

func (e FileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MessageType string

const (
	MessageTypeText   MessageType = "text"
	MessageTypeEvent  MessageType = "event"
	MessageTypeCall   MessageType = "call"
	MessageTypeVoice  MessageType = "voice"
	MessageTypeCircle MessageType = "circle"
)

var AllMessageType = []MessageType{
	MessageTypeText,
	MessageTypeEvent,
	MessageTypeCall,
	MessageTypeVoice,
	MessageTypeCircle,
}

func (e MessageType) IsValid() bool {
	switch e {
	case MessageTypeText, MessageTypeEvent, MessageTypeCall, MessageTypeVoice, MessageTypeCircle:
		return true
	}
	return false
}

func (e MessageType) String() string {
	return string(e)
}

func (e *MessageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageType", str)
	}
	return nil
}

func (e MessageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SystemFiletypesEnum string

const (
	SystemFiletypesEnumAvatar     SystemFiletypesEnum = "avatar"
	SystemFiletypesEnumFileInChat SystemFiletypesEnum = "file_in_chat"
	SystemFiletypesEnumVoice      SystemFiletypesEnum = "voice"
	SystemFiletypesEnumCircle     SystemFiletypesEnum = "circle"
)

var AllSystemFiletypesEnum = []SystemFiletypesEnum{
	SystemFiletypesEnumAvatar,
	SystemFiletypesEnumFileInChat,
	SystemFiletypesEnumVoice,
	SystemFiletypesEnumCircle,
}

func (e SystemFiletypesEnum) IsValid() bool {
	switch e {
	case SystemFiletypesEnumAvatar, SystemFiletypesEnumFileInChat, SystemFiletypesEnumVoice, SystemFiletypesEnumCircle:
		return true
	}
	return false
}

func (e SystemFiletypesEnum) String() string {
	return string(e)
}

func (e *SystemFiletypesEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemFiletypesEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemFiletypesEnum", str)
	}
	return nil
}

func (e SystemFiletypesEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
